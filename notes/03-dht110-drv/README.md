# DHT11 驱动
> 目标： 完成 DHT11 模块驱动， 实现温度和湿度的读取

## 1. 实现流程
基于原始的裸GPIO驱动方式，DHT11 控制方式是通过一个GPIO 来实现，需要先申请GPIO资源，然后设置GPIO方向和模式，最后读取/设置GPIO值。
### 1.1 DHT11 控制流程
1. 主机将对应的 GPIO 管脚配置为输出，准备写入数据；
2. 主机发送一个开始信号(一个低脉冲(18ms) + 一个高脉冲(20-40us))
3. 主机将对应的 GPIO 管脚配置为输入， 准备接收数据；
4. DHT11 发送响应信号(一个低脉冲(80us) + 一个高脉冲(80us));
5. DHT11 发送数据
    0: 50us 低 + 26~28us 高
    1: 50us 低 + 70us 高
6. DHT11 发送结束信号
    DHT11 拉低总线 50us, 然后释放总线，总线进入空闲状态，高电平

## 2. 信息确认
根据硬件电路，确认芯片引脚，GPIO 组，GPIO 号，引脚方向，引脚模式，引脚值。
根据DHT11 接口情况，只需要一个GPIO， 我这里使用的是扩展接口3脚，对应的SoC PE11, 
详细信息如下：
`pin 139 (PE11): input bias disabled, output drive strength (20 mA)`

## 3. 代码思路
### 3.1 拆解步骤
按照上面的控制流程大致可以分为以下步骤：
1）发送开始信号
* 配置GPIO为输出
* 拉低 18ms
* 拉高 30 us
* 切换GPIO 为输入
2）等待响应信号
按照协议，检测
* 低 80us
* 高 80us
代码要等待，这里就需要用定时器了；
3） 读取数据
这个有个问题，要读多少个字节？，感觉文档没介绍，等会在确认；
拆解位 一位数据读取
* 先等待 50us 低电平
* 读到高电平开始计时，得到电平的宽度
* 根据电平宽度判断数据是0还是1
4）等待结束信号
* 低50us
* 高

### 3.2 编写代码思路

我这里不介绍驱动，注册等一些骨架，只记录下关键业务思路；

```shell
 先模拟一个波形看看
   时间 ─────────────────────────────────────────────────────────→

GPIO
电平     主机                     DHT11 响应              数据位(bit0)      bit1 ...
        ┌─────┐ ┌─────┐         ┌─────┐┌─────┐        ┌────┐┌────┐
        │ LOW │ │ HIGH│         │ LOW ││ HIGH│        │LOW ││HIGH│
        └─────┘ └─────┘         └─────┘└─────┘        └────┘└────┘
        18ms     30ms            80us    80us     50us   26/70us

实际一个GPIO 波形

时间(us) →
t0        t80        t160
|---------|----------|
LOW       HIGH
```


由上可以简单看出来一个数据的传输过程；

#### 3.2.1 分析课程
不过多描述，老师的课程主要是2个重要的方法：
**`dht11_isr`**:
这个方法的目的就是采样，老师的思路应该是数据不是靠读电平得来的， 而是靠**每一位的高电平持续时间**做区分；
所以在配置中断的时候配置了 上/下沿中断响应，目的就是： 每出现一个边沿，就记录当下的时间错， 这样就能用2个数据相减得到 这一段电平持续了多长时间这个关键数据；

疑问点：`if (g_dht11_irq_cnt == 84) `，这点我没有仔细思考，估计就是根据经验判断了，一次完整通信的边沿次数，感觉不用纠结这里不关键；

**`parse_dht11_datas`：**
这个方法其实一开始看感觉疑问很多，多次阅读后发现这个方法比上一个还容易理解；
`if (g_dht11_irq_cnt < 81)` 这个估计也是根据经验的来的数据，可能是为了同步， 应为协议上写了一个完整数据是 40bit， 1位数据要有一个完整的 高/低电平切换，也就是2次中断触发， 如果小于81 那么可能就是脏数据，直接丢掉等待下一次；

`for (i = g_dht11_irq_cnt - 80; i < g_dht11_irq_cnt; i+=2)`: 一开始这里思考了很久，这里为什么要 +2；
其实就是丢掉低电平；

老师课程的大概思路如上；

#### 3.2.2  自己的思路
* 整体流程如下

1. GPIO 初始化（输出）
2. 主机发送 Start 信号
3. 切换 GPIO 为输入
4. 等待 DHT11 响应（ACK）
5. 对齐 bit 边界（丢弃 1 bit）
6. 读取 40 bit 数据
7. 解析数据 & 校验

```shell
介绍一下伪代码

# GPIO 初始化
gpio_direction_output(gpio, 1);
# 发送 start 信号
gpio_set_value(gpio, 0);
msleep(20);
gpio_set_value(gpio, 1);
udelay(30);
gpio_direction_input(gpio);
# 等待 响应 ACK
wait LOW  (timeout 80us)
wait HIGH (timeout 80us)
这里主要是等待电平变化，不详细考究时间宽度；

# 读数据 40 bit
for (i = 0; i < 40; i++) {

   { 
     # read a bit
        wait LOW   (bit 起点)
        high_us = wait HIGH (测量时间)

        bit = (high_us > THRESHOLD) ? 1 : 0;
   }
    
    
    
    data[i/8] = (data[i/8] << 1) | bit;
}

# 校验数据
data[0] + data[1] + data[2] + data[3];



```

